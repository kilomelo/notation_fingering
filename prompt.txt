我正在调试这段代码，发现结果和预期不符，现在我想用opencv把输出的结果绘制出来，即显示输入的图片，并用线框框出结果
----------------------------------------------------------------
图片结果显示这段程序只识别出了简谱音符下方的歌词行的最后一个字，且没有识别任何目标音符，帮我修正一下
----------------------------------------------------------------
首先你不能预设图片中简谱的音符行只在上方的70%，它可能在图片的任意Y坐标。你应该要区分汉字和数字来确认音符行的Y坐标。
其次这版本的代码也没能正确实现功能，识别出了两个结果，第一个结果是第一小节的连音线，第二个结果是第一小节的前三个音符。
----------------------------------------------------------------
我发现问题了，我输出了n_boxes的所有内容，结果如下：
OCR result [4]: 6
OCR result [6]: 16
OCR result [7]: |
OCR result [8]: 511
OCR result [9]: |
OCR result [10]: 561653
OCR result [11]: |
OCR result [12]: 5322
OCR result [13]: |
OCR result [15]: Il
OCR result [16]: I
其中，不但错把一些乐谱标记、符号、小节线等识别成了文字，原本应该识别的音符也有漏掉的，也有被识别成连续数字的（比如结果中那几个多位数的数字），竟然没有正确识别出一个音符。
----------------------------------------------------------------
这次基本上能正确识别出音符了，某些测试例有识别不全的情况。音高点的识别十分不准确，我希望能增加绘制线来调试，第一：用一条紫色横线绘制出检测到的行的Y坐标。第二：音符的包围盒颜色以“红黄蓝”三个一组循环颜色绘制以区分顺序。第三：绘制检测到的所有点，绘制的颜色需要与其对应的音符的包围盒颜色相同。
----------------------------------------------------------------
1、减小所有调试线条的线宽到原来的一半。
2、去除label绘制，因为会干扰观察线框。
3、“红黄蓝”改为“红橙蓝”，因为黄色在白色背景下看不清。
4、当前opencv窗口是按任意键关闭，改为按除空格键以外的任意键关闭，按空格键切换调试信息的显示与否。
----------------------------------------------------------------
经过观察我发现音符下方的音高点基本能正常识别（一个或两个点），且没有收到时值线的影响。上方的错误率较高，连音线经常被识别被错误识别成了点。我可能需要另一个调试信息绘制模式：绘制未经过工具代码处理的、opencv直接输出的信息（例如图形轮廓？）来了解为什么误报了一些音高点以及为什么少数音符数字没有被正常识别。
你可以把原来的两种模式（原图、最终结果调试信息）扩展为三种模式（原图、原始调试信息、最终结果调试信息），同时保持用空格在三个模式中循环切换。
----------------------------------------------------------------
将原始信息调试模式中线框的绘制同样改为按序号循环颜色，颜色列表为“红、橙、蓝、深绿、紫”，以方便我调试某些音符数字被逻辑代码排除在外的原因
----------------------------------------------------------------
原始调试信息的框仍然不方便观察顺序，每个原始调试信息框的左上方绘制一个序号数字来表示其序号。所有框数字尺寸大小一致，选择为一个能分辨清楚数字且尽量小的字号。
----------------------------------------------------------------
1、定义一个全局的调试信息输出等级（之后简称info level，代码中所有print输出都增加info level阈值，现存在代码中的输出定为1级，只有当info level大于等于1才会输出。
2、原始矩形筛选到最终显示矩形的过程始终，始终保持其在原始矩形列表中的原始序号信息。因为各种条件被排除时，输出原因及原始序号，这个输出的info level为2，以方便我对照原始调试信息中的序号来判断那些被排除掉的矩形都是因为什么原因。
----------------------------------------------------------------
median_h_all = np.median([h for _, _, _, h in candidates])
这一行报错too many values to unpack (expected 4)
----------------------------------------------------------------
调试发现两个未被识别出的音符数字被OCR empty排除掉了，观察发现这一阶段被排除的对象都是汉字或者乐谱上的标记符号，也就是说ocr_single_char的功能有问题，漏掉了一些数字。
----------------------------------------------------------------
在最终结果调试信息把各音符搜索上下方的点使用的区域画出来，颜色和音符框颜色一致
----------------------------------------------------------------
修改搜索上下点的算法。
1、搜索区域的宽度由现在的0.3倍宽度修改为0.6倍高度。因为不同数字的字符宽度不同，但需要搜索的区域一致。
2、不使用findcontours接口来搜索点，而是遍历第一步寻找音符取得的原始矩形范围列表。取完全被搜索区域矩形包含，且并且宽高符合要求（可定为均小于数字矩形高的三分之一）、且中心的x坐标与相对应数字矩形中心的x坐标相差不超过一定阈值（可定为数字矩形高的四分之一）的矩形为圆点。这样不用再调用图形接口，可以优化性能。
3、理论上不存在同时有上方点和下方点的音符，若出现这种情况，输出一条日志等级为0的warning。
----------------------------------------------------------------
把所有影像识别准度的阈值参数都几种到一个对象里，这个对象在main中赋予值作为参数传入extract_notes。赋予值时每一项写一行并详细注释其作用，方便用户统一修改。
----------------------------------------------------------------
1、修改音符的八度偏移计算规则：如果上下点数都大于0，则维持原warning的输出的同时，将上点数改为0。然后再计算八度偏移。
2、给extract_notes增加可选输入参数：调号（key），字符串类型，默认“C”。参数值可能包括1或2个字符，其中第一个字符是字母且只能从“C”、"D"、"E"、"F"、"G"、"A"、"B"中取，区分大小写；第二个字符可能有也可能没有，只能从“#”、“b”（小写）中取，代表升或者降。如果传入的参数值不符合要求，在方法开头将参数改为“C”并输出等级为0的warning。
3、extract_notes的输出值中的notes列表的列表项，增加音高值，字符串类型。这个值根据degree、octave_offset和传入的key计算得来，举个例子：如果key=G，degree=2，octave_offset=0，则音高为"A3"；又例如：如果key=D,degree=3,octave_offset=1,则音高为“F#4”。计算结果用升号还是降号，需要根据该调音阶的规则来，例如A调是: A-B-C#-D-E-F#-G#，Bb大调: Bb-C-D-Eb-F-G-A。
4、给extract_notes方法增加注释，详细说明输入参数和输出参数。
----------------------------------------------------------------
我需要给note增加属性articulation来表示这个音是否是音头，同时增加检测是否是音头的逻辑。
判断标准是：
如果一个音符的前一个音符的pitch值与该音符相同，且与前音符被同一个延音线连接，则该音符不是音头，其余情况的音符是音头。
判断音符是否被连音线连接的方法：
需要先在获得原始轮廓框后整理出延音线，这一步可以在粗过滤尺寸的阶段执行。判断标准是宽和高的比大于一定阈值（例如2）。
判断一个音是否被延音线连接，可以在上下方点检测后。遍历延音线列表，如果一个延音线的矩形的左下角在上方点检测框内，则这个音被该连音线连接且是起始音；如果一个延音线的矩形的右下角在上方点检测框内，则这个音被该连音线连接且是结束音。需要注意的是，一个音有可能被多个连音线连接并同时作为起始点或作为一个连音线的起始点与另一个连音线的结束点，所以不能在遍历列表时检测到符合要求的连音线后立即退出遍历。
----------------------------------------------------------------
模式2绘制调试信息时，如果音符是音头，则线宽为2，否则线宽为1（只需要修改音符矩形绘制，不需要修改点及其他的绘制逻辑）
----------------------------------------------------------------
某测试用例中有音符数字未被OCR识别，应该修改哪个参数？
----------------------------------------------------------------
把notation_detect代码中的main挪到notation_fingering代码中，调用notation_detect中的方法，实现相同的功能
----------------------------------------------------------------
extract_notes输出一个对象，包含源图片文件路径、notes、row_center_y，raw_boxes，而不是像现在一样输出多个值。
新建notation_renderer代码，建立export_notation方法。输入为：目标文件路径、目标分辨率、源图片偏移、音符检测信息。
目标文件路径：最终保存输出图片时的路径
目标分辨率：输出图片的像素尺寸。
源图片偏移：源图片渲染到输出图片时，左上角相对于输出图片左上角的偏移。
音符检测信息：源图片经过extract_notes处理后输出的对象。
export_notation方法的功能是：
建立一个窗口渲染目标分辨率的图片，图片的alpha值为0，将源图片渲染在目标图片上，渲染混合方式是：颜色值为src_color*(1-dst_alpha)+dst_color*(dst_alpha)，透明度为(1-dst_alpha)*(1-src_alpha)。源图片和目标图片的左上角以输入偏移值为偏移对齐。
窗口监听按键，如果按回车，则保存输出图像到输入参数中的目标文件路径。如果按其他键，则退出程序不保存输出文件。
在notation_fingering中调用extract_notes后调用export_notation，不再调用draw_notes_on_image
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/./notation_fingering.py", line 31, in main
    cx, cy = n.center()
             ^^^^^^^^
AttributeError: 'Note' object has no attribute 'center'
----------------------------------------------------------------
export_notation导出的图片不正确，目前是一张全透明的图片。
----------------------------------------------------------------
1、导出图片时输出一条日志，包含导出文件的绝对路径
2、在渲染源图片时以源图片的灰度值为源图片的alpha值
----------------------------------------------------------------
我解释的有误，应该是1-灰度值作为源图的alpha
----------------------------------------------------------------
export_notation增加输入参数bg_path，该参数应传入一个作为背景的图片文件的路径。输出图像应以此背景图片为背景，如果背景图片尺寸超过目标尺寸，则裁剪；如果目标尺寸超过背景图片尺寸，则平铺。当该参数为空时，以不透明的纯白色为输出图像背景。
预览窗口以及最终保存的图片文件的混合详细规则为：
最底层：背景图片、第二层：源图片。如果称背景图片为dst，源图片为src，混合结果为out的话，out_a=1-(1-dst_a)*(1-src_a);out_c=dst_c*src_c.
----------------------------------------------------------------
源图片改为不再计算灰度，而是采用源图透明度
----------------------------------------------------------------
经过测试，现在的代码有如下问题：
1、预览的图片和保存的图片不一致。
2、预览的图片中，背景没有被源图片覆盖的区域符合预期，被源图片覆盖的区域不符合预期。
3、保存的图片中，背景没有被源图片覆盖的区域为全透明，被源图片覆盖的区域符合预期。
预期中，背景没有被源图片覆盖的区域应该保持背景图片的颜色和alpha值。
----------------------------------------------------------------
把notation_detect中的draw_notes_on_image的渲染调试信息功能合并到export_notation中，删除draw_notes_on_image。
注意需要保留空格切换调试信息渲染模式功能，但不要影响export_notation原有的保存和退出功能。
----------------------------------------------------------------
如果在渲染了调试信息的情况下输出文件的话，调试信息也会被渲染到文件上，这不符合预期。
----------------------------------------------------------------
export_notation增加渲染指法图的feature。
对每个articulation为head的音符，在画布上渲染一张指法图。
export_notation增加一个输入参数fingering_img_path，指包含所有指法图的目录。
指法图从fingering_img_path中搜索，文件名是”音符的pitch_0_0ff.png“，例如一个pitch为G4的音符，对应的指法图文件名是”G4_0_off.png“。如果没找到对应的指法图文件，则输出一条warning并跳过这个音符。
export_notation增加fingering_img_offset参数，形式为(x_offset, y_offset)。其中，x_offset表示所有渲染的指法图的上边中点的x坐标和与其对应的音符的中心点的x坐标的偏移；y_offset表示所有渲染的指法图的上边中点的y坐标和音符所在行的row_center_y的偏移。
指法图的混合规则使用常规的带alpha通道的图片的混合规则。
----------------------------------------------------------------
export_notation增加输入参数：指法图缩放系数，如果未指定则设置为1。
----------------------------------------------------------------
发现一个bug，extract_notes中pitch的计算不正确，测试用例为，G调，音符数字为6，八度偏移为-1，预期pitch为E4，目前错误结果为E3。需要注意非C调音符的八度偏移值与音符所在组别不是一一对应关系。
----------------------------------------------------------------
我增加了包含升降号音符的测试用例，发现ocr识别准确率非常低几乎不可用，特别是一些数字附上升降号后，升降号与数字有重叠。
这个问题可以怎么解决？需要更换音符识别技术吗？
----------------------------------------------------------------
详细介绍一下模板技术，因为我后续可能要识别一些特定的谱面符合，可能也需要用到该技术
----------------------------------------------------------------
新建一个代码来验证模板方案。我的应用场景里，数字的大小、升降号的大小在所有测试用例里都一致。且升降号一定在数字的左上角方向。是不是只需要建立一组包含0-7、升号、降号图片的模板？
帮我在新代码中编写测试程序来跑通使用模板匹配0-7与升降号的流程，最好有可视化的调试渲染
----------------------------------------------------------------
和我说一下准备模板图片的注意事项。
我的测试用例都是白底黑字。是不是模板图片也需要白底黑字？模板图片是不是在完整显示检测对象的前提下裁切到最小不留任何透明margin区域？
----------------------------------------------------------------
各数字图片、升降号图片怎么命名？
----------------------------------------------------------------
我运行了template_match_demo，结果整个图片密密麻麻都是各种颜色的框
----------------------------------------------------------------
我修改了thresh_digit和thresh_acc后还是全是框。帮我修改代码进行全局NMS试试
----------------------------------------------------------------
框仍然布满图片，我发现图片中即使是纯白色区域仍然被检查出重叠的大小不一的框，检查一下代码是不是有逻辑bug
----------------------------------------------------------------
纯白色区域仍然布满框，但这次有数字或图形的区域反而框很少了
----------------------------------------------------------------
这次框减少到正常密度了，但有几个问题：
1、黄色的框和label在白色背景下看不清，请替换为橘色。
2、没有任何蓝色框被检测到。
3、框的位置和内容的位置匹配不上。
----------------------------------------------------------------
这次数字和升降号都被正常识别了，但在一个测试用例里，空白区域识别出两个数字0，label是”0:inf“
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/./template_match_demo.py", line 79, in match_template_single
    matches.append((x, y, w, h, s))
                                ^
NameError: name 's' is not defined. Did you mean: 'ys'?
----------------------------------------------------------------
我想要用模板检测延音线的左右端点，帮我添加相关代码
----------------------------------------------------------------
延音线的形状不止一种，帮我增加延音线（形状2）的左右端点模板，与形状1使用不同的阈值。
----------------------------------------------------------------
两组延音线仍然不够，增加到三组
----------------------------------------------------------------
我想要新增八度点模板及代码
----------------------------------------------------------------
增加一个模板图片查找替换功能，即通过一个模板查找图片中的图形，然后用另一张图片替换。
图形在图片中存在多个实例。
用来查找的图片名为”from{查找编号}.png“，用来替换该图形的图片名为”to(查找编号).png“，其中，查找编号为A至Z的大写字母。
替换规则是将to图片覆盖在查找到的位置，中心点对齐。
查找编号可以在不修改代码的前提下动态增减，所以不能提前将模板及替换图片名称写死在代码中，而是应该搜索目录查找符合规则的替换组。
如果查找替换组的时候发现残缺的组，如缺少from图或缺少to图，则输出warning日志。查找完毕后将所有找到的组输出到日志。
预览时，原图模式应显示原图，可视化模式应显示替换所有替换组后的图片
----------------------------------------------------------------
修改预览规则，可视化模式不再显示替换后的图像，而是把各替换组的from检测框也绘制出来。新增替换结果模式作为2号模式，不显示检测框，只显示替换后的结果图片。默认仍是可视化模式（1），三个模式按空格顺序切换
----------------------------------------------------------------
替换组的to图片命名规则变更：
”to{组别编号}{x_offset}/{y_offset}.png“。新增xy偏移，覆盖到源图片时应用此偏移，均为整数（可能有正负号）。该偏移也可省略，但省略时必须同时省略，不存在只省略x偏移或y偏移的情况。如果”to{组别编号}“后的字符串不符合上述规则则忽略偏移并输出warning。
由于查找/替换模板功能较复杂，对于图片的命名规则要求也较复杂，请在代码中在相应部分增加详细的注释来说明。
----------------------------------------------------------------
修改替换时的逻辑为：
1、首先将查找到的from图形的矩形框向外扩大一个像素，即宽增加2像素，高增加2像素。
2、将原图的框内区域以纯白色覆盖。
3、使用标准混合公式将to图片以目前的位置规则渲染到原图。
----------------------------------------------------------------
修改to图片在有偏移时的命名规则为“to{id}[{x},{y}].png”
----------------------------------------------------------------
修改img_fader、img_cropper两个工具脚本，新增如下功能：在输出完图片后，在输出文件夹中建立一个文本文件，命名为parameters.ini，记录执行命令时传入的参数。例如，在调用img_fader时，调用命令为"python ./img_fader.py ./fingering_img 0.1"，则文本文件中记录“./fingering_img 0.1”，img_cropper的规则与img_fader类似。
----------------------------------------------------------------
(notation_fingering) chenweichu@cwcmm notation_fingering % python ./img_cropper.py ./fingering_img 266 1500 --offset_x 0 --offset_y 360
输入目录: ./fingering_img
输出目录: ./fingering_img_cut
目标分辨率: 266x1500
中心点偏移: X=0, Y=360
--------------------------------------------------
✗ 处理失败: G4_0_off.png - 错误: 'float' object cannot be interpreted as an integer
✗ 处理失败: E5_0_off.png - 错误: 'float' object cannot be interpreted as an integer
下略……
这可能是什么原因？
----------------------------------------------------------------
目前img_cropper保存的参数信息是“./fingering_img 266 1500 0 360”，和我的预期不符，我希望是“./fingering_img 266 1500 --offset_x 0 --offset_y 360”，和我输入的信息一致，方便我下次复制粘贴重新运行
----------------------------------------------------------------
建立一个新脚本template_match_replace.py，主要功能与将原demo脚本相似。
主函数参数：
1、乐谱图片路径notation_img_path
2、模板目录templates_path
功能描述：
1、不再在代码中硬编码模板，而是扫描templates_path目录中所有图片动态获取文件、名称、阈值等信息，按文件名分为两大类：
a.替换组，由搜索模板及替换图片成对组成，主要逻辑与demo中相似，新增逻辑为搜索模板图片的文件名附带阈值信息，规则为“from_{id}_[{thresh}]”，其中thresh为可转换为浮点数的字符串。替换图片的命名规则改为“to_{id}_[{x_offset},{y_offset}]”，相较于demo中的命名规则仅新增两个下划线。替换组的id合法值为大写字母A至Z。
b.常规模板，对应demo中硬编码的数字、升降号、点、左右延音线等对象。命名规则是“{模板名称}_[{thresh}]”，其中thresh也是浮点数的字符串。模板名称不应该包含左右方括号。也不能仅为大写字母A至Z。 对于阈值信息可选的说明： a、b类模板文件命中，阈值信息及其前的下划线为可选的，如果文件名中未读取到阈值信息，则对该模板使用硬编码的默认阈值（暂定0.9）。
对于图片文件名异常的处理： 理论上要求模板目录中的所有图片文件均未a/b两类模板文件中的其中一种，如果遍历到文件名不符合要求的图片文件，则输出异常warning提示该文件名不符合要求。 2、预览及调试信息相关功能与demo中一致，可在代码中硬编码一组常见颜色组（尽量稍暗一些的颜色方便在白色背景中辨认）供模板列表中所有对象循环对应作为调试信息的矩形框颜色。
3、保存图片功能所保存的图片是替换了替换组后的不带调试信息的图片，图片名称为”{乐谱图片名称}_{replaced}.png”，保存在乐谱图片的同级目录。 保存图片的同时，还应保存一个json文件，记录所有模板的识别信息，命名规则为”{乐谱图片名称}__matchinfo.json”，其中： 对于a类替换组，以替换组id作为名称，所记录的位置、大小信息（x、y、w、h、center）为替换图片实际信息（在应用了偏移后），而非检测到的搜索模板位置大小信息。 对于b类常规模板，以模板名称为名称，记录的位置、大小信息为搜索到的矩形框的位置、大小信息。 应理解，不管是a类还是b类，同一个名称下，位置、大小信息均是一个列表，对应搜索到的多个实例。列表项的排列顺序按位置的x从小到大，即对应图片上的从左到右。
总体的要求：应尽量完善注释提高代码的可读性，至少要移植原demo代码中的有效的注释。应效仿img_crppper代码中的使用说明，方便第一次在命令行中使用该脚本的用户了解功能。
----------------------------------------------------------------
blended = blend_alpha(dst_roi, fg_crop)
              ^^^^^^^^^^^
NameError: name 'blend_alpha' is not defined
----------------------------------------------------------------
现有代码有如下问题：
1、你丢失了demo代码中关于用白色覆盖替换组from检测框的功能，导致输出的图片上，渲染的to图片与from重叠显示。
2、不需要在matchinfo文件中保存替换模板from的检测信息，因为这个info是描述输出后的图片的，此时已无from图片中的图案。
3、调试信息显示状态下，不应该显示替换组的to图片的检测框。而且从根本上来说也不应该把to图片用作模板检测，他们只是用来渲染覆盖的。
4、替换组在info文件中的名称（包括调试信息状态下检测框label上的名称）应该只有id如“A”、“B”，而不是from_A或to_A。应该注意到调试信息渲染状态下只有from图片的检测框和id，而info文件中只有to图片的信息。
5、调试信息模式下显示在检测框上方的label，目前显示了小数点后两位的可信度例如“1.00”、“0.96”。我希望改为百分数的格式（省略百分号）如“100”、“96”。
----------------------------------------------------------------
这次测试结果显示替换组的to图片仍然参与了模板检测和调试信息的绘制，仔细检查相关代码，确保不再使用to图片作为模板。
另外，info文件中记录的替换组的识别对象分数，应该为其替换前的from图片的识别分数。
----------------------------------------------------------------
matchinfo文件新增一个字段，src_img_path，记录原乐谱文件的绝对路径
----------------------------------------------------------------
matchinfo文件新增一个字段，在src_img_path之后，replaced_img_path：记录输出的图片文件的绝对路径
----------------------------------------------------------------
修改notation_detect脚本，删除所有检测及ocr逻辑，改为使用template_match_replace输出的json数据作为输入，仅做逻辑判断来确定乐谱信息。 notation_detect的输入参数为： 1、matchinfo：json文件的路径。
2、key：乐谱的调号，合法值见源代码中的KEY_SCALES列表
所需要做的事情：
1、确定哪些数字为乐谱的音符。
2、确定各音符的升降号状态。
3、八度点状态。
4、计算各音符的音高。
5、确定各音符是否为音头。
做这些事情使用的算法：
1、与原代码类似，将0-9数字按y聚类，同一行的音符数字应该在同一y段，取数量最多的行。
2、检测每个音符的左上角是否有升号或者降号，判断标准为虚拟一个检测框，检测框的右下角为数字的中心，检测框的宽高均为数字高的一半。如果有某一个升号框或降号框的右下角落入该检测框，则视为音符有升号或者降号。一个音符只能同时有一个升号或降号，所以遍历时可以提前退出。
3、与检测升降号类似，虚拟下检测框与上检测框，完全被检测框包围的dot对象属于音符的高八度点或低八度点。两个检测框的宽和高为数字高度乘以一定系数（与原代码逻辑相似），上检测框的下沿与数字框的上沿同y值，下检测框的上沿与数字框的下沿同y值（即取消原代码中的margin_y），点中心与数字中心的水平容差判断也与源代码相似。
4、计算音高的逻辑与原代码中的逻辑基本相同，区别在于需要新增升降号的判断。有升降号的音符的音高计算应该注意按照实际情况而不是简单的在查找KEY_SCALES后拼接升降号。例如E调的2#对应的音高应为G而不是F##，2b对应的音高为F而不是F#b。又例如C#调的3#的音高为F#，3b音高因为E。
另外，有了升降号后，八度的计算更为复杂，需要考虑边界情况。例如C#调的7#的音高计算等。
5、要确定音符是否为音头，需要先确定音符上方是否有延音线的起始或结束。同样是虚拟一个检测框，宽度与高度为数字高度乘以一定系数（宽高系数不同），如果某个名字以“slur_left”为开头的对象（因为可能为slur_left1、slur_left2等，所以只能以此前缀作为判断）的左下角落入检测框内，则判断该音符有延音线的起始。如果某个名字以“slur_right”为开头的对象的右下角落入检测框内，则判断该音符有延音线的结束。
确定了各音符是否有延音线后，即可判断音符是否是音头，只有当一个音符与前一个音符的音高相同，且该音符有延音线的结束，同时前一个音符有延音线的起始，这个音符才不是音头。 脚本的预览功能有所修改，只保留两个模式：原图模式和音符信息模式。原图模式只显示template_match_replace脚本输出的图像，即输入json文件中的replaced_img_path指向的文件。音符信息模式以replaced_img为底，按照从左到右的顺序，使用颜色循环渲染音符数字的框以及他们对应的上下点检测框、延音线检测框、升降号检测框。音符信息模式应该在音符数字框的上方label标明该音符的音高。两个模式仍然按空格键切换，同时新增回车键输出功能。
回车键输出功能为：按回车后关闭预览，同时新建或覆盖一个json文件到原图片文件同级目录。json文件的命名是“{原图片文件名}_notes.json”。这个文件包含以下信息： 1、replaced_img_path：与输入json文件中的replaced_img_path相同。
2、key：调号。 3、音符列表，列表项包括：音符数字、八度偏移、升降号情况、音高、是否为音头、数字框中心点位置、数字框宽、数字框高、音符所在行的row_center_y。
----------------------------------------------------------------
with open(path, "r", encoding="utf-8") as f:
         ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: 'p.json'
处理一下输入文件路径异常的情况
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/notation_detect.py", line 232, in main
    for bx, by, bw, bh, _ in sharp_boxes:
        ^^^^^^^^^^^^^^^^^
ValueError: too many values to unpack (expected 5)
----------------------------------------------------------------
把各种检测框的长宽系数单独列出来写在main里方便修改，类似于之前代码中的DetectParams
----------------------------------------------------------------
需要像原代码一样输出基本的检测结果信息，比如音符行的y坐标、每个音符的信息
----------------------------------------------------------------
调试信息模式还需要渲染row center的水平线，使用紫色0.5线宽
----------------------------------------------------------------
需要修改调试信息渲染模式，拆分为四种状态：
状态1：只渲染主行水平线、音符数字框。
状态2：只渲染上下点检测框，并在数字左侧渲染label，label下沿与数字下沿平齐，信息是音符的octave_offset。
状态3：只渲染升降号检测框，并在数字左侧渲染label，label下沿与数字下沿平齐，信息是音符的accidental。
状态4：只渲染延音线检测框，并在数字左侧渲染label，label下沿与数字下沿平齐，信息是检测到的状态（无延音线/左/右）。
以上四种状态都需要在在音符数字的右侧渲染label，label下沿与数字下沿平齐，信息是音符的音高。
以上四种状态和原图状态共计五种预览状态，空格切换，初始是状态1
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/notation_detect.py", line 352
    if has_slur_start and has_slur_end:
IndentationError: unexpected indent
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/notation_detect.py", line 352
    if has_slur_start and has_slur_end:
IndentationError: unexpected indent
----------------------------------------------------------------
cv2的putText能够设置为右对齐吗？
----------------------------------------------------------------
状态2时需要渲染八度点，状态3时需要渲染升降号的框，状态4时需要渲染各延音线的框
----------------------------------------------------------------
你刚才误修改了我微调过的代码，所以我回退了这次修改，希望你之后再修改代码时尽量基于代码的现状修改，而不是完全按照历史对话记录修改，因为我可能在你修改的基础上又做了一些和对话记录不一致的微调。
另外，你似乎误解我上次请求的含义了，我说的“状态2时需要渲染八度点”值的是在状态2时渲染输入json文件中记录的所有dot，而不是只渲染被判定到的dot。同理“状态3时需要渲染升降号的框”、“状态4时需要渲染各延音线的框”也是一样的。
----------------------------------------------------------------
你还是错误修改了我的代码，我已经将音高label移到了数字的右上角，你又改回到右下角了；我将原左侧label移到了右下角，你又改回到了左下角了。请不要在有这样的行为
----------------------------------------------------------------
我又将你的修改回退了，现在重新实现我的需求：我说的“状态2时需要渲染八度点”指的是在状态2时渲染输入json文件中记录的所有dot，而不是只渲染被判定到的dot。同理“状态3时需要渲染升降号的框”、“状态4时需要渲染各延音线的框”也是一样的。
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/notation_detect.py", line 338, in main
    for bx, by, bw, bh, _ in dots_all:
                             ^^^^^^^^
NameError: name 'dots_all' is not defined. Did you mean: 'dots_hit'?
----------------------------------------------------------------
行中心线只在状态1时渲染
----------------------------------------------------------------
DetectParams中各项添加纤细说明注释
----------------------------------------------------------------
在main中的示例里也添加相同的注释
----------------------------------------------------------------
上下点检测框的宽高系数使用不同的系数
----------------------------------------------------------------
去掉上下点的水平容差相关逻辑及参数
----------------------------------------------------------------
升降号检测框的对齐规则改为：检测框的右侧中点和音符数字的中心点对齐。
----------------------------------------------------------------
最后输出的json文件名有误，应该为“{src_img_name}_notes.json”
----------------------------------------------------------------
解释一下这句代码：
stem = os.path.splitext(os.path.basename(info.get("src_img_path", replaced_img_path)))[0]
----------------------------------------------------------------
现在开始修改notation_renderer脚本。
将原detection参数改为notes_json_path，即notation_detect脚本保存的XXX_notes.json文件的路径。其他逻辑沿用现代码。
但现代码有一个需要补充的地方，就是当在指法图目录中按音符音高搜索图片文件时，如果没有找到对应图片，需要做同音异名的兜底。例如，搜索“B#4_0_off”文件没有找到，就需要搜索“C5_0_off”。具体哪些音高有同音异名，你需要有一个完善的算法来处理。我建议预先读取指法图片目录，将所有指法图片的音高部分（即文件名中第一个下划线之前的字符串）转换为midi音高编号，记录一个midi编号对应图片路径的字典。在需要找某个音高的指法图片时，也将音高字符串转为midi音高编号，去这个字典中取。当然，如果找不到还是需要输出warning的。
----------------------------------------------------------------
export_notation方法去掉target_path参数，最终输出的图片文件命名改为“{src_img_name}_fingering.png”，其中，src_img_name为*_notes.json中记录的replaced_img_path文件的文件名。
----------------------------------------------------------------
我需要将template_match_replace、notation_detect、notation_renderer三个脚本组成一个工具链，使他们既能独立调用，又能被notation_fingering顺序调用。当被notation_fingering调用时，notation_fingering的main函数中应该首先定义原始乐谱图片路径、调号、模板目录、指法图片目录、最终输出图片高、最终输出图片中乐谱图片的偏移、背景图路径、指法图片偏移、指法图片缩放。然后在后续的执行中分别传给对应的调用对象。
notation_fingering被调用时，应该首先调用template_match_replace，如果按了任意键退出，则不再继续调用后面的流程；如果按了回车生成了结果，则继续调用notation_detect。调用notation_detect时也是一样，只有回车生成了结果才继续调用notation_renderer。为了实现这一链路是不是需要略微修改template_match_replace和notation_detect以方便notation_fingering得知执行结果。
----------------------------------------------------------------
目前notation_renderer无法单独调用，与预期不符
----------------------------------------------------------------
notation_renderer只有一个预览模式，没有显示原图的预览模式
----------------------------------------------------------------
我没有说清楚，预期是notation_renderer只有一个预览模式，没有显示原图的预览模式
----------------------------------------------------------------
notation_fingering运行时，如果用户按任意键退出而没输出时，也应该输出类似“template_match_replace 未保存结果，后续流程终止。”这样的日志
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/notation_renderer.py", line 69
    bool: 是否已保存（按回车保存返回 True，否则 False）。
               ^
SyntaxError: invalid character '（' (U+FF08)
----------------------------------------------------------------
目前notation_renderer的main方法的代码风格和任务管线的其他两个代码不一致，修改为一致的风格
----------------------------------------------------------------
notation_renderer的fingering_dir、width、height参数不能作为可选参数，他们是必须的
----------------------------------------------------------------
notation_renderer脚本改名为notation_render
----------------------------------------------------------------
我刚才说错了notation_renderer应该改名为notation_rendering
----------------------------------------------------------------
三个步骤输出的文件改为写在原始乐谱图片同级目录下的与原始乐谱图片文件名同名的目录下，而不是直接写在原始乐谱图片文件的同级目录下
----------------------------------------------------------------
给notation_rendering增加一个feature。
目前指法图片的命名规则是“{pitch}_0_off.png”，我希望修改为“{pitch}_{variant_id}_off.png”，因为同一个音高有不止一种指法。其中，variant_id为从0开始的整数。当为音符选取指法图片时，默认选择0号变体。
在预览窗口中，用户可以在指法图片显示的范围内点击鼠标来切换对应音符所选取的指法图片变体。每点击一次选择下一张变体图片。例如如果存在“G5_0_off”、“G5_1_off”、“G5_2_off”三张指法图，默认应该选择G5_0_off，点击一次后切换到G5_1_off，再点击切换G5_2_off，再点击切换会G5_0_off。注意处理变体序号不连续或不是从0开始的情况，这可能是准备图片有误造成的，但也需要遵守类似的规则。每次点击切换指法图，应该输出合适的信息来告知用户切换的是哪个音符，和切换到了几号变体等信息。
原代码中的midi音高相关的逻辑不应该受到这次feature新增的破坏。
最终输出图片时应以最终选择的指法图来渲染。
最后，notation_rendering在你编写后可能已经被我有所修改，请不要随意修改当前代码中与新feature无关的其他内容。
----------------------------------------------------------------
我运行notation_fingering整合流程时，即使已经保存了最终结果，仍然输出了未保存的日志：
Saved exported image to: /Users/chenweichu/dev/notation_fingering/p/p_replaced_fingering.png
notation_rendering 未保存结果，流程结束。
----------------------------------------------------------------
目前notation_detect关于音高计算的逻辑有bug。
需要重新设计音高计算的算法。这次我们不再以音名记录音高，而是以midi音高编号来记录音高，这样规则更简单。

首先应该通过查表，得到各调的1（无升降八度点）所对应的音高：
C->60
G->55
D->50
A->57
E->52
B->59
F#->54
C#->61
F->53
Bb->58
Eb->51
Ab->56
Db->61
Gb->54
Cb->59
然后，通过查表得到在不考虑八度偏移的情况下音符与该调的1之间的音程。表为：
“1b": -1,
    “1”: 0,
    “1#”: 1,
    “2b": 1,
    “2”: 2,
    “2#”: 3,
    “3b": 3,
    “3”: 4,
    “4b”: 4,
    “3#”: 5,
    “4”: 5
    “4#”: 6,
    “5b": 6,
    “5”: 7,
    “5#”: 8,
    “6b": 8,
    “6”: 9,
    “6#”: 10,
    “7b": 10,
    “7”: 11,
“7#”: 12,

通过音程+1对应的音高得到音符在不考虑八度升降的情况下的音高。
最后计算升降八度修，一个升八度点提高12个半音，一个降八度点减少12个半音。
这几轮计算后得到音高（midi音高数值）。
需要注意的是，虽然notation_detect导出的json数据中记录的数值是midi音高数值，但显示音高的label上显示的应该是科学音名，例如60对应C5，只使用带升号的音名即可。

相对应的notation_rendering的代码也需要做一些修改（因为输入的notes数据变了）
----------------------------------------------------------------
目前notation_detect中有很多遗留的没有用到的代码，清理一下。注意不要删除有意义的注释。
----------------------------------------------------------------
notation_rendering在预览时，如果点击的是只有一个变体的指法图，不要再反复输出“Fingering switch: pitch G#6 -> variant 0”，而是输出“该音高只有一种指法，无法切换”。
另外，以后在对话框里回复我时使用中文。
----------------------------------------------------------------
notation_fingering代码的main中的这些参数：
    templates_path = "templates"         # 模板目录
    fingering_img_path = "fingering_img_cut_fade"  # 指法图目录
    target_resolution = (1700, 550)      # 输出画布 (width, height)
    source_offset = (10, 0)             # 乐谱在输出中的偏移 (x, y)
    bg_path = "bg.png"                   # 背景图路径，空则白底
    fingering_img_offset = (0, 50)       # 指法图顶边中点相对音符中心/行的偏移
    fingering_scale = 0.25               # 指法图缩放系数
都存储到一个config.ini文件中，notation_fingering的main新增输入参数：
1、notation_img_path
2、key
3、config_path
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/notation_fingering.py", line 12, in load_config
    cfg.read(path, encoding="utf-8")
    ~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/configparser.py", line 737, in read
    self._read(fp, filename)
    ~~~~~~~~~~^^^^^^^^^^^^^^
  File "/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/configparser.py", line 1052, in _read
    ParsingError._raise_all(self._read_inner(fp, fpname))
                            ~~~~~~~~~~~~~~~~^^^^^^^^^^^^
  File "/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/configparser.py", line 1081, in _read_inner
    self._handle_rest(st, line, fpname)
    ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^
  File "/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/configparser.py", line 1105, in _handle_rest
    raise MissingSectionHeaderError(fpname, st.lineno, line)
configparser.MissingSectionHeaderError: File contains no section headers.
file: 'config.ini', line: 1
'templates_path=templates\n'
这是怎么回事，是因为我的config.ini文件内容不对吗？
----------------------------------------------------------------
notation_fingering的main方法增加对config的预检测，应对这种异常，或者兜住然后自己输出异常信息也行，看你觉得哪种做法更好
----------------------------------------------------------------
功能基本完成了，现在将目录里的六个脚本文件整理一下，删除没有用到的代码，编写详细的注释。注意不要误删功能代码。
----------------------------------------------------------------
现在我需要编写一个小工具，帮我新建一个python文件叫做layer_blending，功能是搜索一个目录，目录中有若干png图片，遍历这些图片，将这些图片作为上层，另一张特定的图片作为底层，使用标准透明混合方式绘制为一张图片，然后保存混合后的图片文件。
脚本输入：
1、包含若干作为上层图片的目录
2、作为下层图片的图片文件路径
3、保存输出文件的目录
4、输出文件的文件名附加后缀
几个重要信息：
所有混合的图片尺寸均一致，若不一致输出错误后跳过。
输出文件的命名方式是“{上层图片文件名}_{附加后缀}.png”。
----------------------------------------------------------------
修改notation_detect输出的json文件命名规则为：
"{原图片文件名}_{key}_notes.json"。即在原来的命名的基础上增加调号。同时在json文件中增加”src_img_path“字段，就像matchinfo文件中那样。
另外，修改notation_rendering输出的图片文件命名规则为："{原图片文件名}_{key}_fingering.png"，注意其中使用的是原图片文件名，而不是replaced文件的文件名。
----------------------------------------------------------------
notation_rendering输出的图片文件保存路径错了，应该保存在原图片目录下与原图片同名的目录中，就和流程中上两个步骤输出的文件的保存目录一样。
----------------------------------------------------------------
我要修改notation_rendering的输出图片功能。
目前的版本为输出一张图片，表示了乐谱上所有音符的指法信息。现在我需要输出多张图片，来展示每个音符的演奏状态。
目前版本随音符渲染的指法图片为"{pitch}_{variant_id}_off.png"，表示的是音符未演奏的状态。我新增了一个包含所有指法演奏状态的指法图的目录，命名规则是"{pitch}_{variant_id}_on.png"。
新版本应该输出这些图片：
1、所有音符的指法图均为off状态的图片。命名为"{原图片文件名}_{key}_fingering_0.png"
2、从左到右依次遍历是音头的音符，此音符的指法图为on，其他音符的指法图为off，输出一张图片。命名为"{原图片文件名}_{key}_fingering_{id}.png"，其中id为从1开始递增的整数。
即，如果乐谱包含四个音符，其中有两个是音头，则总共应该输出1+2=3张图片。
为此，notation_rendering应该将原参数fingering-dir的名称改为fingering-off-dir，并新增输入参数fingering-on-dir在fingering-off-dir参数之后，表示包含所有指法演奏状态的指法图目录。
与此同时，config.ini文件也应该做相应修改。
异常处理：
如果某个音符只找到对应的on图片而没有找到对应的off图片，则使用on图片替代off图片来渲染，同时输出错误信息。
----------------------------------------------------------------
修改notation_rendering的预览功能，目前空格键没有任何作用，我希望改为按空格键切换显示将要输出的图片。默认预览0号图片，即所有音符的指法图为off状态的图片。按一次空格切换到下张图片，当当前预览图片为最后一张时，再按空格切换回第一张。
预览或输出图片时，如果找不多对应的on图片，则输出warning信息，告诉用户没找到的图片文件的预期目录，方便用户去查找。
不管当前预览的是哪张图片，按回车输出的都是整套图片。
----------------------------------------------------------------
你不应该输出这样的信息：Warning: on 指法缺失，使用 off 代替 (midi=89, variant=0), 期望目录: fingering_img_on_cut_fade
而是应该把”期望目录: fingering_img_on_cut_fade“换成”缺失的图片：{缺失图片的绝对路径}“
----------------------------------------------------------------
我仔细检查了你输出的错误信息，发现你声称的缺失图片都是存在的，比如：
Warning: on 指法缺失，使用 off 代替 (midi=71, variant=0), 缺失的图片: /Users/chenweichu/dev/notation_fingering/fingering_img_on_cut_fade/B4_0_on.png
你可以自己检查一下该文件。
----------------------------------------------------------------
现在是不是在调用notation_rendering的时候就加载了所有指法图片？感觉打开这个脚本速度很慢，能不能改为懒加载，只有在需要预览渲染或者输出图片时才加载要用到的指法图片？
----------------------------------------------------------------
输出图片时无响应的时间过长，能不能够在输出时在预览窗口增加一个进度条？同时日志也即使输出进度？
----------------------------------------------------------------
目前输出进度信息如下：
开始保存指法序列，共 33 张 ...
[2/33] 保存 /Users/chenweichu/dev/notation_fingering/l2/l2_F_fingering_1.png
[3/33] 保存 /Users/chenweichu/dev/notation_fingering/l2/l2_F_fingering_2.png
下略……
没有0号图的输出信息。
另外，既然已经输出了这个进度信息，就不要输出
Saved exported image to: /Users/chenweichu/dev/notation_fingering/l2/l2_F_fingering_0.png
Saved exported image to: /Users/chenweichu/dev/notation_fingering/l2/l2_F_fingering_1.png
Saved exported image to: /Users/chenweichu/dev/notation_fingering/l2/l2_F_fingering_2.png
这些信息了吧
----------------------------------------------------------------
你在新增这个feature的过程中把点击切换指法变体的功能弄丢了
----------------------------------------------------------------
现在我要给这个工作流新增一个步骤，建立一个python文件video_rendering，功能是将notation_rendering输出的图片序列转换为视频文件。
输出的视频是用来指导观众进行乐器演奏的。所以理论上作为视频关键帧的图片序列的各张图片的时间点应该和音乐演奏中各音符的时间点相符。
为此，我们需要这个工具导入一段音频文件，格式是常见的wav或mp3。用户通过预览窗口的ui界面来配合音频确定每张关键帧的具体时间点。
预览窗口的尺寸和布局：
窗口宽与notation_rendering输出的图片的宽度相同，高为图片高度的两倍。
上半部分显示音频文件的波形图（如果为双声道则显示左声道），下半部分显示当前预览的图片。
上半部分的底部有两行操作区，上面一行是标记按钮组，下面一行是状态操作按钮。操作区以覆盖的方式渲染在波形图上，会遮挡部分波形图。
预览窗口的功能和状态：
工具有两个状态：标记状态和播放状态。
标记状态：
在标记状态下，用户可以通过操纵标记按钮，来确定每张图片的时间节点。
标记按钮组内的标记按钮的数量为notation_rendering输出的图片序列数量-1，从左到右依次对应从第二张图片开始的每张图片。上面显示当前图片的序号（从1开始的）。
标记按钮组最多只能有一个按钮处于按下状态，当某个按钮按下时，用户可以在波形图上的任意位置点击鼠标左键，以确定按钮代表的图片对应的时间节点。被按下的按钮只会在组内其他按钮按下时才取消按下状态，所以在按下状态时，用户不但可以点击，也能够按住鼠标后在波形图区域拖动以确定时间节点位置。
初始时，除了0号图片（即所有音符指法图为off状态的图片）已确定时间节点为0s外，其他图片均未确定时间节点。当除0号图片以外的图片确定了时间节点后，波形图上应显示一条颜色明显的竖线，表示这张图片的时间节点，并在竖线的上端右侧渲染label，内容是图片的编号。
每当有标记按钮被按下时，下半部分的图片区域显示按钮所对应的图片。没任何按钮被按下时，则显示0号图片。
播放预览状态：
操作按钮为横向排列的若干按钮。有左对齐的两个按钮：播放按钮、停止按钮。标记状态下点击播放按钮则切换到播放预览状态，所有标记按钮抬起。播放预览状态时，点击停止按钮或音频播放结束则回到标记状态。
播放预览状态时，音频播放，上方的波形图区域的背景会分为左右两个颜色，当前播放时间点左边的是颜色1，右边是颜色2，以展示当前播放进度。
播放时，下方的图片区域会根据当前时间节点显示对应的图片，即刚开始播放时显示0号图片，播放到任意图片的时间节点时则切换为该图片。
视频导出功能：
操作按钮行有右对齐的导出按钮，导出按钮只在标记状态时可点击，点击时进行合法性检测，检测通过后导出视频文件。
检测的内容为：
1、所有图片都确定了时间节点。
2、所有图片的时间节点是递增的。
3、所有图片的时间节点间隔不小于0.1s。
如果检测不通过，则弹出错误提示框，提示用户错误原因，并返回标记状态。
如果检测通过，则弹出确认提示框，提示用户确认导出视频，点击确认后开始导出视频。
导出的视频时长应与音频时长相同，视频分辨率与序列图片的分辨率相同。音频文件作为视频的音轨。
视频文件名称与传入的参数中的目录名称相同，格式是mp4.
video_rendering的输入参数：
1、包含序列帧图片的目录。序列帧文件的命名格式是"XXX_{id}",id从0开始。
2、音频文件路径。
增加新流程后需要修改notation_fingering文件增加音频文件参数定义。与前三个步骤一样，这一步骤也需要保证能单独调用。
----------------------------------------------------------------
目前版本中，按钮没有正常显示，只在按钮应该在的位置显示了几行问号，不能确定按钮的位置是否正确，按钮的交互似乎也不正常
----------------------------------------------------------------
大部分按钮上还是问号乱码，右侧你似乎显示了红色字体的提示文字？也是问号乱码。
播放按钮、停止按钮、导出按钮上的文字都是乱码，点击好像也没有反应。
将UI上所有中文改为英文以规避乱码问题
----------------------------------------------------------------
Space switch | Button to mark | P play | S stop | E export
这行提示和标记按钮组位置重叠了。另外，标记按钮组、操作按钮的区域点击不应该穿透到波形区域，否则会造成在切换标记按钮时上一个按钮的时间节点会被错误设置到下一个按钮所处的位置。
----------------------------------------------------------------
标记状态下在鼠标按住时不能拖动设置时间标记。另外不能正常播放音频，以及导出的视频没有音频。查看了代码似乎是导入moviepy.editor不成功，但我已经使用pip install moviepy  安装成功了，请问为什么还是导入不了？
----------------------------------------------------------------
(notation_fingering) chenweichu@cwcmm notation_fingering % pip install moviepy imageio[ffmpeg] simpleaudio                                
zsh: no matches found: imageio[ffmpeg]
----------------------------------------------------------------
1、设置关键帧时间时，日志不再输出类似”Frame 13 time 12.516s“的信息。
2、波形区域表示各关键帧时间点的竖线上方的label改为两行，第一行仍然是关键帧编号，第二行是时间（秒，精确到小数点后两位）
----------------------------------------------------------------
目前鼠标事件还是穿透了操作按钮区域到达波形图区域，和预期不符
----------------------------------------------------------------
不要再输出”Select marker: frame 10“这种提示。
----------------------------------------------------------------
1、奇数关键帧的竖线颜色改为绿色，并且label的y位置需要下移一点，避免在前后关键帧距离过近时在ui上label文字重叠。
2、标记按钮的文本根据所代表关键帧是否已标记而变化，未标记时仍为数字，标记后为数字加一个√。
3、在输出Error: 存在未標記的時間點这样的错误信息的同时需要在ui上弹出一个警告对话框，注意文字要翻译为英文避免乱码。
----------------------------------------------------------------
1、把波形图区域的颜色反色显示。
2、√仍然被显示为了乱码，替换为done。
3、需要弹窗提示导出检测未通过原因。
----------------------------------------------------------------
1、波形图前景色改为白色。
2、波形图区域左下角的提示文字颜色使用白色，右下角的提示文字颜色改为亮红色。
3、关键帧时间线的颜色逻辑你搞错了，应该是根据关键帧编号决定，比如0号图片、2号图片的竖线是亮红色，1号图片、3号图片是绿色。而不是根据已标记的顺序的奇偶。
----------------------------------------------------------------
你没有实现我之前提的这个需求的后半部分：”奇数关键帧的竖线颜色改为绿色，并且label的y位置需要下移一点，避免在前后关键帧距离过近时在ui上label文字重叠。“
----------------------------------------------------------------
你对这个需求理解有误，不是当前后关键帧距离过近时才下移label，而是把所有奇数关键帧的label都下移。并且你目前实现的下移距离太小了。
----------------------------------------------------------------
1、奇数关键帧的label下移距离还是太小了，改为30像素。
2、点击导出时报错：
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 370, in on_mouse
    cv2.displayOverlay("video_render", f"Validation failed: {msg}", 2000)
    ~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cv2.error: OpenCV(4.12.0) /Users/xperience/GHA-Actions-OpenCV/_work/opencv-python/opencv-python/opencv/modules/highgui/src/window.cpp:1228: error: (-213:The function/feature is not implemented) The library is compiled without QT support in function 'displayOverlay'
----------------------------------------------------------------
1、ui上的提示文字仍然有中文，会造成乱码。
2、ui上的提示文字的红色背景太短，应该根据文字内容长度适配。
3、ui上的提示文字显示时长改为2s。
4、奇数关键帧的label下移距离还是太小了，改为32像素。
----------------------------------------------------------------
def validate_timestamps(ts: List[float]) -> Tuple[bool, str]:
    if any(t is None for t in ts):
        return False, "Some frames are not marked"
    for i in range(1, len(ts)):
        if ts[i] <= ts[i - 1]:
            return False, "時間點需嚴格遞增"
        if ts[i] - ts[i - 1] < 0.1:
            return False, "相鄰時間間隔需>=0.1s"
    return True, ""
这里用于显示到ui上的字符串有中文，会造成乱码
----------------------------------------------------------------
ui上的提示弹出信息的颜色改为：背景色为半透明橘色，前景色为白色。
----------------------------------------------------------------
半透明橘色的透明度太高了，改低一些。
在导出完成时也应该弹出提示信息。
----------------------------------------------------------------
当前版本点击导出按钮时，如果检测没通过能正常弹出提示，如果检测通过了，则没有任何反应，即没有日志输出也没有弹出框，也不写入视频文件。
----------------------------------------------------------------
目前波形图区域的鼠标消息层级问题依然不符合预期。设置关键帧时间的鼠标消息应该只在标记按钮组上沿及以上区域生效。
----------------------------------------------------------------
导出的视频时长不对，与音频时长不同。观察视频发现视频只截止到最后一个关键帧设置的时间点。
----------------------------------------------------------------
把弹出提示的代码整理成一个通用的方法，避免重复书写。
----------------------------------------------------------------
现有机制能不能够实现下一个提示弹出时，上一个提示自动消失的功能？
----------------------------------------------------------------
好的，帮我实现这个代码
----------------------------------------------------------------
这一版代码的弹出提示完全不显示了
----------------------------------------------------------------
我希望在导出检测通过，执行导入动作之前弹出提示”exporting...“，这个提示在导入完成钱一直显示，直至被导入完成提示或导入失败提示覆盖。
----------------------------------------------------------------
exporting提示并没有弹出来
----------------------------------------------------------------
Exporting video -> line1.mp4
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 411, in on_mouse
    temp_canvas = apply_overlay(temp_canvas, w, h)
                  ^^^^^^^^^^^^^
NameError: name 'apply_overlay' is not defined
----------------------------------------------------------------
为什么在336行与209行分别调用了addweighted接口，而不是统一在一个弹窗接口调用？
----------------------------------------------------------------
调整标记按钮在各状态下的显示效果。
按下状态下：文字仅显示为数字，背景色为橘色。
非按下状态：文字仅显示为数字，如果已标记，背景色为浅绿色，否则为浅灰色。
----------------------------------------------------------------
删除波形图区域右下角的提示当前选择帧的label
----------------------------------------------------------------
我在当前的python环境里安装了moviepy与ffmpeg，但moviepy.editor找不到，是什么原因？
----------------------------------------------------------------
(notation_fingering) chenweichu@cwcmm notation_fingering % pip show moviepy
Name: moviepy
Version: 2.2.1
Summary: Video editing with Python
Home-page: 
Author: Zulko 2024
Author-email: 
License: MIT License
Location: /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages
Requires: decorator, imageio, imageio_ffmpeg, numpy, pillow, proglog, python-dotenv
Required-by: 
(notation_fingering) chenweichu@cwcmm notation_fingering % python -m pip install "moviepy" "imageio[ffmpeg]"
Requirement already satisfied: moviepy in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (2.2.1)
Requirement already satisfied: imageio[ffmpeg] in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (2.37.2)
Requirement already satisfied: decorator<6.0,>=4.0.2 in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from moviepy) (5.2.1)
Requirement already satisfied: imageio_ffmpeg>=0.2.0 in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from moviepy) (0.6.0)
Requirement already satisfied: numpy>=1.25.0 in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from moviepy) (2.2.6)
Requirement already satisfied: proglog<=1.0.0 in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from moviepy) (0.1.12)
Requirement already satisfied: python-dotenv>=0.10 in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from moviepy) (1.2.1)
Requirement already satisfied: pillow<12.0,>=9.2.0 in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from moviepy) (11.3.0)
Requirement already satisfied: tqdm in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from proglog<=1.0.0->moviepy) (4.67.1)
Requirement already satisfied: psutil in /Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages (from imageio[ffmpeg]) (7.1.3)
(notation_fingering) chenweichu@cwcmm notation_fingering % python -c "import moviepy, sys; print(moviepy, sys.path)"
<module 'moviepy' from '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages/moviepy/__init__.py'> ['', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python313.zip', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/lib-dynload', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages']
(notation_fingering) chenweichu@cwcmm notation_fingering % 
这些信息是否能够诊断？
----------------------------------------------------------------
我确认了环境并没有搞混，也没有任何同名文件，请在代码中合适的位置增加报错输出，以方便判明原因。
目前的状况是ide中提示import moviepy.editor as mpy无法解决，并且运行时音频无法播放，导出视频时提示”未安裝 moviepy 或 ffmpeg（導入錯誤: No module named 'moviepy.editor'），視頻無音軌。“
----------------------------------------------------------------
运行时输出：
[pydub import warning] ModuleNotFoundError("No module named 'pyaudioop'")
[moviepy import error] ModuleNotFoundError("No module named 'moviepy.editor'") | executable=/Users/chenweichu/dev/miniconda3/envs/notation_fingering/bin/python | sys.path=['/Users/chenweichu/dev/notation_fingering', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python313.zip', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/lib-dynload', '/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages'] | moviepy.__file__=/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages/moviepy/__init__.py
仍然无法播放音频。
输出视频时输出：
提示: 未安裝 moviepy 或 ffmpeg（導入錯誤: ModuleNotFoundError("No module named 'moviepy.editor'")） | executable=/Users/chenweichu/dev/miniconda3/envs/notation_fingering/bin/python | moviepy.__file__=/Users/chenweichu/dev/miniconda3/envs/notation_fingering/lib/python3.13/site-packages/moviepy/__init__.py，視頻無音軌。
----------------------------------------------------------------
运行时报错：
[pydub import warning] ModuleNotFoundError("No module named 'pyaudioop'")
----------------------------------------------------------------
现在开始播放时预览窗口会失去响应，并在音频播放完后崩溃，输出：
(notation_fingering) chenweichu@cwcmm notation_fingering % python video_rendering.py line1 test_audio.wav
zsh: segmentation fault  python video_rendering.py line1 test_audio.wav
----------------------------------------------------------------
File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 31
    HAVE_PYDUB = True
    ^^^^^^^^^^
SyntaxError: expected 'except' or 'finally' block
----------------------------------------------------------------
点击播放仍然不能播放音频，尝试导出视频时输出：
Exporting video -> line1.mp4
Export failed: 'AudioFileClip' object has no attribute 'set_duration'
----------------------------------------------------------------
点击播放时能正常播放音频，界面有相应，但点击停止虽然能将界面状态恢复标记状态，但音频仍在播放。播放结束后程序崩溃，输出：
zsh: segmentation fault  python video_rendering.py line1 test_audio.wav
----------------------------------------------------------------
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 373
    nonlocal playback_obj
    ^^^^^^^^^^^^^^^^^^^^^
SyntaxError: no binding for nonlocal 'playback_obj' found
----------------------------------------------------------------
表现仍然和上一版一样。我建议你重新思考一下代码逻辑，你应该以一个音频播放器的思路来设计这个程序，这只是一个有一些附加功能的音频播放器。
----------------------------------------------------------------
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 112
    global PLAYBACK_BUFFER
    ^^^^^^^^^^^^^^^^^^^^^^
SyntaxError: name 'PLAYBACK_BUFFER' is assigned to before global declaration
----------------------------------------------------------------
表现和上一版一样。我们不再在这个代码的基础上修改了。
重新建立一个audio_player.py,使用opencv作为ui库，实现简单的音频播放、停止、进度拖拽功能。
----------------------------------------------------------------
播放时按空格停止，或者拖拽进度均会造成程序崩溃：
(notation_fingering) chenweichu@cwcmm notation_fingering % python audio_player.py test_audio.wav
zsh: segmentation fault  python audio_player.py test_audio.wav
----------------------------------------------------------------
这次能正常实现功能了，现在把video_rendering中所有音频相关的功能的代码都删除，替换为audio_player代码中的相关代码。
----------------------------------------------------------------
音频播放正常，但点击stop按钮无法停止音频播放。
音频播放时波形图区域没有正常显示播放进度，预期应该是该区域通过背景颜色来指示播放进度。
输出的视频有正常的音轨了。
----------------------------------------------------------------
停止按钮能正常停止了，但波形区域仍然没有任何变化
----------------------------------------------------------------
还是一样，波形区域仍然没有任何变化
----------------------------------------------------------------
仍然不能显示进度，重新思考一下波形区域的绘制逻辑，可以尝试先不在该区域绘制背景色，以排除任何遮挡问题。
----------------------------------------------------------------
背景色仍然是纯黑色，没有任何变化。
----------------------------------------------------------------
还是纯黑色底，你是不是修改错位置了？先尝试把纯黑色底去掉，或者把波形曲线改个颜色看看
----------------------------------------------------------------
波形曲线已变成淡蓝色，但该区域的背景仍然是纯黑色，没有进度显示
----------------------------------------------------------------
没有看到你所谓的亮绿色、深灰色进度和红色竖线。请完全推翻波形曲线绘制逻辑，重头编写波形渲染的代码
----------------------------------------------------------------
和你重写前表现没有任何改变。这样吧，video_rendering代码中只保留波形曲线的绘制代码，播放状态时，在波形区域的上部覆盖绘制一个类似于audio_player代码中实现的进度条。进度条的透明度为50%。
----------------------------------------------------------------
并没有显示出进度条，请完全删除波形图的绘制逻辑，只绘制不透明的进度条
----------------------------------------------------------------
现在上半区域只有灰色背景，播放时也没显示进度条
----------------------------------------------------------------
我把代码回退到上一个稳定的版本了，现在我们换个思路。
之前在标记模式时，我们在每个关键帧位置绘制了一条竖线。现在我们用同样的方法，播放模式下，在当前播放进度所在的位置处绘制一条竖线。这条竖线应该比较粗，颜色是橘色，且竖线的上端右侧有label，内容是当前播放进度的时间，单位秒，精确到小数点后两位。
----------------------------------------------------------------
还是没显示出进度竖线，我怀疑不是绘制问题，而是你没有拿到正确的播放进度。现在在播放模式时，每当你拿到一个新的播放进度时，输出一条日志。
----------------------------------------------------------------
通过日志得知，你正常获得了实时播放进度。那我们再检查一下绘制方面的逻辑。
尝试在切换到播放模式时，绘制一条进度竖线到音频时长一半的位置。
----------------------------------------------------------------
没有看到橘色进度竖线，请在绘制完橘色竖线后不再更新其位置，让我能确切的观察到。
----------------------------------------------------------------
还是没有观察到橘色竖线，请确认绘制橘色竖线的代码与绘制各关键帧竖线的代码相同，并确保不再在播放过程中更新这条竖线
----------------------------------------------------------------
还是没看到橘色竖线，但关键帧竖线能正常看到，这是为什么呢？
----------------------------------------------------------------
那就按你说的修改吧
----------------------------------------------------------------
还是没看到橘色竖线
----------------------------------------------------------------
我已经手动修复了播放进度显示的问题，后面的修改以当前代码状态为基础。
首先去掉波形区域的反色显示设置，恢复为正常颜色设置。
----------------------------------------------------------------
1、将波形区域画布背景色改为深灰色。
2、将波形曲线颜色改为淡蓝色。
----------------------------------------------------------------  
我运行了代码，波形曲线目前颜色是淡粉色，是怎么回事？
----------------------------------------------------------------
1、播放状态下，下半图片预览区域根据目前播放到的进度渲染不同的关键帧。
2、播放状态下，无法操作标记区按钮，同样也无法通过空格切换当前预览的关键帧及当前标记。
----------------------------------------------------------------
请解释一下什么是中点竖线？
----------------------------------------------------------------
你怎么把八百年前我和你提的需求拿出来了？我早就手动修复了播放进度问题，不再需要什么中点竖线了，你自己好好回头看看我们的聊天记录
----------------------------------------------------------------
我已经回退代码到稳定状态了，现在重新实现这个需求：
1、播放状态下，下半图片预览区域根据目前播放到的进度渲染不同的关键帧。
2、播放状态下，无法操作标记区按钮，同样也无法通过空格切换当前预览的关键帧及当前标记。
----------------------------------------------------------------
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 361, in main
    bottom_frame = get_frame_for_time(current_play_time, ts_source)
TypeError: main.<locals>.get_frame_for_time() takes 1 positional argument but 2 were given
----------------------------------------------------------------
把偶数帧的竖线颜色改为黄色。
将输出视频文件写入目录改为图片序列目录
----------------------------------------------------------------
导出视频文件时的日志应包含视频文件的绝对路径
----------------------------------------------------------------
重新实现这个需求：将输出视频文件写入目录改为图片序列目录。你刚才没有做对。
----------------------------------------------------------------
新增feature：当一个关键帧的时间比它前面任何关键帧的时间更靠前时，绘制这个关键帧的竖线时使用红色
----------------------------------------------------------------
我刚才的描述有误，正确的应该是：当一个关键帧的时间比它前面任意一个已标定的关键帧的时间更靠前时，或者一个关键帧的时间比它之后任意一个已标定的关键帧的时间更靠后时，绘制这个关键帧的竖线时使用红色。比如5号关键帧的时间是9s，3号关键帧的时间是10s，这两个关键帧的竖线都需要用红色绘制
----------------------------------------------------------------
新增feature：新增保存功能：点击保存按钮或在导出视频后进行保存操作。
保存操作：将目前已标定的关键帧序号及时间写入json文件，文件名与视频文件名相同，保存在视频文件所在目录。
保存按钮在导出按钮的左边。
运行脚本时，应首先尝试读取该json文件，如果存在，则读取其中存储的各关键帧的时间信息并赋予各个关键帧。
----------------------------------------------------------------
    ~~~~^^
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 329, in main
    play_ts = load_timestamps(ts_json_path, len(frames))
              ^^^^^^^^^^^^^^^
NameError: name 'load_timestamps' is not defined. Did you mean: 'validate_timestamps'?

----------------------------------------------------------------
1、只允许在标记模式下进行保存操作。
2、将停止播放的快捷键由s改为o
3、增加保存操作的快捷键s
4、当使用快捷键或者按钮进行保存操作时，弹出提示框，同时输出相应日志，日志应包含保存的文件的绝对目录。导出视频文件的同时保存则不用弹出提示框，但也需要输出日志。
5、保存按钮的位置改为与导出按钮一样右对齐，且在导出按钮左边
----------------------------------------------------------------
目前有如下bug：
1、使用快捷键保存一次输出了两条日志。
2、保存按钮点击没有反应。
3、快捷键提示label没有做相应修改。
----------------------------------------------------------------
点击保存或使用快捷键均会一次输出两条日志：
(notation_fingering) chenweichu@cwcmm notation_fingering % python video_rendering.py line1 test_audio.wav
已保存时间标记: /Users/chenweichu/dev/notation_fingering/line1/line1.json
已保存时间标记: /Users/chenweichu/dev/notation_fingering/line1/line1.json
----------------------------------------------------------------
新增feature，不再使用输入的完整音频文件作为关键帧标记和导出的参考音频，而是使用其一部分。
操作区新增两个整数输入框，分别用于输入需要截取部分的开始时间和结束时间，单位为毫秒。
开始时间默认是0，结束时间默认是音频全长。当输入非法值时自动限定到合法范围内，例如开始时间输入负数则自动修正为0，结束时间输入大于音频全长则自动修正为音频全长。
波形图区域只绘制截取部分，当开始值或结束值变化后自动重新绘制。如果已标定的关键帧的时间超过截取范围，则删除标定。特殊情况是：每次开始值变化后，0号帧自动标定到开始值。
各关键帧的标定时间改为以毫秒为单位的整数，其值应该是相对于音频文件的起始，也就是0毫秒，而不是相对于截取范围的开始值。
保存功能增加对开始值和结束值的记录。
导出视频的时长为截取部分的时长，而不是音频全长。
----------------------------------------------------------------
是的，按以上规划实现代码
----------------------------------------------------------------
确认可接受上述重构
----------------------------------------------------------------
我确认
----------------------------------------------------------------
继续修改代码，你能行的！
----------------------------------------------------------------
好的，那就先实现这一项改动：
新增区间状态并用毫秒保存：
在加载音频后设 segment_start_ms=0，segment_end_ms=音频总长ms。
在保存/读取 JSON 时，增加字段 segment_start_ms、segment_end_ms，时间戳都用毫秒整数（相对原始音频起点）。
----------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 55, in <module>
    def load_timestamps(json_path: str, count: int) -> Tuple[List[Optional[int]], int, int]:
                                                                  ^^^^^^^^
NameError: name 'Optional' is not defined
----------------------------------------------------------------
修正这个错误
----------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 638, in <module>
    main()
    ~~~~^^
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 420, in main
    timestamps, loaded_start, loaded_end = load_timestamps(ts_json_path, len(frames))
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
ValueError: too many values to unpack (expected 3)
修正这个错误
----------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 607, in <module>
    main()
    ~~~~^^
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 354, in main
    play_ts = timestamps.copy()
              ^^^^^^^^^^^^^^^
AttributeError: 'tuple' object has no attribute 'copy'
修正这个错误
----------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 607, in <module>
    main()
    ~~~~^^
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 354, in main
    play_ts = timestamps.copy()
              ^^^^^^^^^^^^^^^
AttributeError: 'tuple' object has no attribute 'copy'
仍然有相似报错，请通篇检查代码防止再一次对话只修改一处
----------------------------------------------------------------
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 608, in <module>
    main()
    ~~~~^^
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 460, in main
    save_timestamps(ts_json_path, timestamps)
    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^
TypeError: save_timestamps() missing 2 required positional arguments: 'segment_start_ms' and 'segment_end_ms'
修正这个错误
----------------------------------------------------------------
接着进行这一项修改：
修正波形和标记时间：
绘制波形时只取 wave[start:end] 段，X 轴映射到该段时长。
标记时间以毫秒记录
----------------------------------------------------------------
请完成以下修改：
波形绘制仅使用截取段 wave[segment_start_ms:segment_end_ms]，X 轴按该段时长映射。
标记时间统一用毫秒存储，但仍然使用秒显示
----------------------------------------------------------------
鼠标交互设置关键帧的时间戳的逻辑有问题，比如点击了13s的位置，但关键帧时间却设定到了0.013秒
----------------------------------------------------------------
完成以下修改：
播放/进度计算使用截取段时长。
导出视频帧数使用该时长；ffmpeg 合并音频时应传入 -ss start_ms -to end_ms 截取音频片段。
----------------------------------------------------------------
当前播放和导出都是从音频的起始开始播放，这和预期不符，请修正
----------------------------------------------------------------
当前导出视频的音轨播放正常了，但预览播放没有任何声音，虽然进度条是正常走的
----------------------------------------------------------------
完成以下修改：
在控制区添加两个整数输入框（起始/结束 ms），回车或失焦时校正到合法范围（start>=0，end<=音频总长，start<end）。变更后重绘波形并清理超出范围的标记。
----------------------------------------------------------------
在当前的ui框架下，输入框是不是不太好实现？
----------------------------------------------------------------
如果不实现输入框，你有没有什么别的实现方案能实现业务效果的？
----------------------------------------------------------------
我已经回退了你刚添加的输入框相关代码。现在我们尝试用另一种交互设计。
我计划在一个区域渲染整个音频的波形，在这个全波形区域进行鼠标交互来设定截取段的开始和结束时间。
原波形区域仍然按原计划只渲染截取段的波形。
请实现该设计的第一步：
当前的上半部分（波形区域）划分为两部分：
上半部分的上1/3高度（占总窗口高度的1/6）绘制全音频的波形。
上半部分的下2/3高度为现在的波形绘制区域，绘制规则保持不变。
注意原来限定在波形区域的标记交互，需要改为限定在截取段波形区域。
----------------------------------------------------------------
我测试了这一版代码，发现在全波形段区域仍能进行标定关键帧时间戳的交互，这和预期不符
----------------------------------------------------------------
好的，请修改以修复这个问题
----------------------------------------------------------------
什么意思？你现在权限异常了吗？获取不到文件的写入权限了吗？
----------------------------------------------------------------
如何允许你全文获取文件内容？
----------------------------------------------------------------
我想要确认一下我们的合作方式，我简单回顾一下刚才发生的事情：
1、我在对话框中点击你完成的修改框中的undo按钮，回退了一次修改。
2、我提出了新的需求。
3、你回复我说代码状态混乱，你无法再进行代码修改。
也就是说如果我对你的某次修改不满意，在对话框内点undo回退是一种有风险的行为，会造成后续工作无法进行。
我的理解对吗？
----------------------------------------------------------------
我不认为当前代码以哪份为准是一个需要讨论的问题，逻辑上来讲，当前代码一定是以代码的当前文件状态为准的，为什么你会觉得这是一个问题？
----------------------------------------------------------------
draw_global_wave中在绘制波形的polylines之前绘制一个矩形，矩形的高度和全波形区域高度一致，矩形的左边对应截取段的开始位置在全波形中的位置，右边对应截取段的结束位置。以此来显示截取段在全波形中的区域。
矩形的颜色使用浅灰色，只有填充没有描边
----------------------------------------------------------------
1、全波形区域中的描述截取段范围的矩形颜色改为深灰色。
2、提高全波形、截取波形的采样密度，目前采样密度过低导致部分波形丢失了细节。
----------------------------------------------------------------
再次提高波形的采样密度
----------------------------------------------------------------
现在来编写全波形区域的交互逻辑：
用户在全波形区域使用鼠标拖拽来确定截取段范围。
鼠标拖拽的动作以鼠标在全波形区域按下为开始。
鼠标拖拽动作以鼠标移出全波形区域为取消。
鼠标拖拽动作以鼠标在全波形区域抬起为完成。
动作开始到动作完成（或取消）之间，称为动作进行。
动作进行期间，原来绘制在在全波形区域的用于表示截取范围的矩形，改为以按下位置的x坐标为左边，以鼠标当前位置的x坐标为右边。
动作完成时判定动作是否有效，判定标准为：抬起位置的x坐标所代表的时间戳比按下位置x坐标的时间戳多至少2s。
如果动作完成时判定为无效，则不执行动作结果。
如果动作执行成功，则更新截取段的开始和结束时间。并自动更新0号帧的时间戳为截取段开始时间，同时清理超出截取时间段的关键帧时间戳。
----------------------------------------------------------------
1、当动作进行状态下鼠标移出了全波形区域，动作应立即取消退出进行状态回到正常状态。
2、动作开始时将当前标记帧置为none
3、如果动作进行状态下，开始位置的x坐标比鼠标当前位置x坐标大，则用于绘制范围的矩形的颜色使用深红色，以表示动作的非法状态。
----------------------------------------------------------------
你还是没有实现”动作进行时，当鼠标离开全波形区域，则取消动作“这一需求。
----------------------------------------------------------------
动作进行期间：
在矩形框的左上角绘制label，显示按下位置所代表的时间，单位秒，精确到小数点后两位。label的左端与矩形框的左端对齐。
在矩形框的右上角绘制label，显示鼠标当前位置所代表的时间，单位秒，精确到小数点后两位。label的左端与矩形框的右端对齐。
----------------------------------------------------------------
上面所说的时间标签，在动作方向非法（矩形显示未深红色）期间，不绘制。
----------------------------------------------------------------
进一步提高波形图的采样密度以提高显示准确性。
----------------------------------------------------------------
新增feature，标记模式时，如果当前标记帧不为none且已存在标记，则当前标记帧的标记竖线的粗细比正常渲染时大一倍。
----------------------------------------------------------------
将倍率改为三倍
----------------------------------------------------------------
导出视频时报错：
Exporting video -> /Users/chenweichu/dev/notation_fingering/line1/line1.mp4
Traceback (most recent call last):
  File "/Users/chenweichu/dev/notation_fingering/video_rendering.py", line 738, in on_mouse
    temp_canvas[0:h, 0:w, :] = render_wave_with_marks(active_btn)
    ~~~~~~~~~~~^^^^^^^^^^^^^
ValueError: could not broadcast input array from shape (367,1700,3) into shape (550,1700,3)
----------------------------------------------------------------
在全波形区域设定了新的截取范围后需要输出日志，告知原截取范围和新截取范围，以及清除了哪些关键帧的时间戳
----------------------------------------------------------------
对video_rendering的修改暂时告一段落，我们现在开始对notation_rendering进行修改。
在预览及导出除0号序列帧以外的其他序列帧时，还需要在对应的音符数字处绘制一个指示矩形，以表示当前序列帧所指的演奏状态。
指示矩形应该在背景绘制后，乐谱图片绘制前进行绘制。
指示矩形只有填充，没有描边，填充颜色为白色。
矩形的中心点与数字音符的中心点对齐。
指示矩形的宽和高为所有音符的平均高度乘以系数，代码需新增此宽系数及高系数作为参数。
config.ini中也需要新增此宽系数与高系数，并在notation_fingering中进行获取传递给工作流中的notation_rendering。
----------------------------------------------------------------
目前的指示框的渲染顺序错误，导致指示框遮盖了音符数字，需要调整渲染顺序。
----------------------------------------------------------------
notation_rendering新增指示框颜色作为参数，默认为白色，同时config.ini中新增此参数。
----------------------------------------------------------------
指示矩形改为圆角矩形
----------------------------------------------------------------
  File "/Users/chenweichu/dev/notation_fingering/notation_rendering.py", line 112, in draw_filled_rounded
    cv2.circle(canvas_rgba, (x1 + r, y1 + r), r, color, -1, cv2.LINE_AA)
    ~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cv2.error: OpenCV(4.12.0) :-1: error: (-5:Bad argument) in function 'circle'
> Overload resolution failed:
>  - Scalar value for argument 'color' is not numeric
>  - Scalar value for argument 'color' is not numeric
----------------------------------------------------------------
  File "/Users/chenweichu/dev/notation_fingering/notation_rendering.py", line 119, in draw_filled_rounded
    cv2.circle(canvas_rgba[:, :, 3], (cx, cy), r, alpha, -1, cv2.LINE_AA)
    ~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
cv2.error: OpenCV(4.12.0) :-1: error: (-5:Bad argument) in function 'circle'
> Overload resolution failed:
>  - Layout of the output array img is incompatible with cv::Mat
>  - Expected Ptr<cv::UMat> for argument 'img'
----------------------------------------------------------------
我回退了这次关于指示框的修改，因为我想尝试另一种方案：用一张指示框图片来渲染。
现在开始所做的修改都是以当前代码文件的状态为基准。
给notation_rendering新增一个参数note_indicator_img。
config.ini中也新增此参数.
指示框图片应该在预览及导出除0号序列帧以外的其他序列帧时，在对应的音符数字处绘制。
指示框图片的中心点与音符数字的中心点对齐。
指示框图片的绘制顺序应该在背景绘制后，乐谱图片绘制前进行绘制。采用标准alpha混合。
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------